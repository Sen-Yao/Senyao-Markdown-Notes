# 指针运算

## 算术运算

运算的移动个数都是目标类型空间！

### 指针与整数的加减运算

含义：当指针当前指向位置为基准，向高地址端or低地址端跳过n个目标类型空间后，得到一个新的指向

最经典的使用是数组操作，例如

```
int a[2]={1,2};
px = a;
```

则此时`px+1=2;`,即`a[1]`的值

### 自增运算

++，--，是类似的

`y=*px++;`

相当于：

`y=*(px++)`

先运算*，再运算++

`y=++(*px)`

先解引用，再++，最后赋值

### 指针相减

同一组，数据类型一致的指针
运算结果是数据个数

实际上是地址值减完以后除以sizeof


### 关系运算

不等号比较，高地址大于低地址

有效性判断

## 指针的赋值

* 把同数组类型的变量地址赋给指针
* 把一个指针的值赋给同数据类型的指针
* 把数组入口地址指向相同数据类型的指针（二维数组用例）
* 动态内存分配
  * 在C++，对于定义变量，系统要自动分配内存空间保存
  * 有时候不知道具体应用需要的内存（旅游团）
  * 因此需要动态分配内存空间，按需分配

标准c中使用的库函数

`#include <stdlib.h>`

输入void型指针，成功返回非零地址值

`#include <malloc.h>`

输入无符号整数，输出void型指针

malloc()函数分配的内存空间放在数据区的堆中

有一个无符号整数型的形参size，用来制定内存空间大小（字节为单位）

对字符串采用表达式

`strlen()`得到字符串长度


```
char * pf = NULL;
pf=(char *)malloc(strlen("Hello')+1); //加一个用来存放结尾符'\0'
if (pf==NULL)
{
    puts("Out of memory");
    exit(1);
}
strcpy(pf,"Hello");
free(pf);
pf=NULL;
```

分析：

第二行指向堆空间，借助malloc函数，在队空间中分配一个动态的内存空间。

堆空间的使用和释放都是程序员自己掌握的，可以横跨任何函数

释放意思：

操作系统的内存分配表，在里面填充记录，其中起始地址，字节数，分配的进程

malloc成功后，表里多了记录

释放时，把表拿出来，找到起始地址，这块空间多少字节，把记录做了标记，作为空闲区而非被占用区。但释放不会清理内的数据，只是更改了内存空间的使用权限

因此释放后，指针还是指着原来的位置，但是指的是一个未分配数据，因此pf成了野指针。需要将野指针归零。

在C++中，可以采用new语法来分配

`pf = new char[strlen("Hello')+1]`

`delete[] pf;`

malloc()函数执行成功时返回值首地址，失败时返回空指针，因此必须检测是否空指针

避免同一堆空间被释放两次，因为查表找不到那条记录，无法释放

正确使用的好习惯

在free之前ptr曲直不能被修改，否则无法访问堆对象，也无法free释放

free后归零

#### 常见错误

没有建立指向，严禁把指针交给用户去输入

```
char *p;
scanf("%s",p);
```

错误！

```
char str[20];
*p=str;
scanf("%d",p);
```
指针类型错误

经过操作以后指针指向了无效非法区域后继续进行操作，导致指针越界，比如for循环后，忘记返回悲愤之

高阶指针，指针类型和复制的地址不匹配，如

```
int **p;
int a;
p=&a;
```

此时为二级指针，直接访问变量，不合法





