# 指针

---

## 建立指针

`<存储类型> <目标数据类型> *指针名=初始地址>`

指针变量使用之前必须初始化，指针未初始化，但仍然有指向。

如果一个指针指向不明确的地址，更改此指针可能发生危险。

因此在初始化指针时，如果没有给其分配应有的地址，应该给它分配“NULL”（空地址）来保证其安全性，如

`int *pa = NULL;`

## 指针的数据

* 指针名
* 指针类型——指针变量只能指向同一目标类型的变量
* 指针地址
* 指针值

## void 指针（void *）

目的：使指针传输更具通用性

在介绍完明确类型的指针后，介绍一种抽象类型指针，目标不明确，称为“无类型指针”

`<存储类型> void * 指针变量名`

void类型的指针可以指向具体目标，但反过来，将void型指针赋给其他各种类型指针时，必须采用强制类型转换，将它变成指向相应数据类型的指针

例如

```
int *pIntArr \\创建int类型的指针;
pIntArr=(int *)malloc(10*sizeof(int)) \\将void类型指针强制转成int型;
```

再例

`free(void *)`

此函数设计是的传入借口，为了保证通用性，传入借口采用void设计

## 指针运算

### 取地址运算符&

“引用”运算符

单目&是取地址运算符，其表达形式为

`&变量`

其参与运算的变量必须为左值

* 可以的：int、char、double、int a[4]、
* 不可以的：a、register

### 取内容运算符*

“解引用运算符”

标识形式

`*指针`

比如

```
int a, *pa=&a;
*pa=9;
(*pa)++;
(*(char *)pa)='a'
```

对于最后一行`(*(char *)pa)='a'`的分析：

首先，分析设计的变量，在这行之前，pa指向a的地址，假设a的地址为2000；

在这行里，

`(char *)pa`将pa转为char型指针

`*(char *)pa`以char形式寻找pa的所指向的内容

`(*(char *)pa)='a'`将'a'写入char型指针pa的内容

---

### 指针的正确运用

* 定义时，必须按照被间接访问变量的类型来定义指针变量；
* 初始化时必须用被间接访问变量的地址给指针变量赋值
* 然后才能使用指针来解引用目标
* 用完指针后，指针变量置0，休息！

若指针的寿命比对象长，可能出现出现野指针，即指向意想不到的内容，导致错误

### NULL 指针

表示不指向任何目标，要使一个指针变量不工作，就赋给他NULL值

在一些返回指针的库函数中，NULL表示一种特定返回状态，表示一场

对一个NULL指针进行解饮用是非法的，因此在解引用之前，必须确保它并非NULL指针#
